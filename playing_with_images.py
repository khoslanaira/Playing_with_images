# -*- coding: utf-8 -*-
"""Playing_with_images.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A-rbVXtNzxWVBWTPRaF196eUItYI4pmd
"""

import numpy as np

#Each channel of the image is a matrix of 3x3
red_channel = np.array([[255,0,0], [0,255,0],[0,0,255]])
green_channel = np.array([[0,255,0], [0,0,255],[255,0,0]])
blue_channel = np.array([[0,0,255], [255,0,0],[0,255,0]])

#stack the matrices along a new axis to craete an image
rgb_image = np.stack((red_channel, green_channel,blue_channel), axis = -1)

# Assuming 'image' is a NumPy array representing an image
# Cropping to select 50 to 100 rows and 25 to 75 columns
cropped_image = rgb_image[50:100, 25:75]

#Function to display an image using matplotlib
import cv2
import numpy as np
import matplotlib.pyplot as plt

def display_image(title,image):
  plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
  plt.title(title)
  plt.axis('off')
  plt.show()

#Create a random image of size 28x28 with a big diagonal line

random_image= np.zeros((28,28),dtype=np.uint8)

for i in range(28):
  random_image[i,i]=255
  random_image[i,27-i]=255
display_image('Random Image',random_image)

#step1: Load an image
image = cv2.imread('example.jpg')

#Display original image
display_image("Original Image",image)

print(type(image))
print(image.shape)

#step2 : Crop the image
cropped_image = image[50:300, 100:400]
display_image("Cropped Image",cropped_image)

#Step 3: Adjust brightness and contrast
#Increase brightness by adding some value to all pixels

bright_image = cv2.convertScaleAbs(image,alpha=1,beta=50)
display_image("Bright Image",bright_image)

bright_image2= (image + 50) % 255
display_image("Bright Image2",bright_image2)

grayscale_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
display_image("Gray Image",grayscale_image)

#Step5: Flip image horizontally

flipped_image= cv2.flip(image,1) # 1 for horizontal
display_image("Flipped Image",flipped_image)

#Flip vertically
flipped_image = cv2.flip(image,0) # 0 for vertical
display_image("Flipped Image",flipped_image)

# Transpose and verify the shape
f_image = np.transpose(image, (1, 0, 2))
print("Transposed image shape:", f_image.shape)  # Should be (height, width, channels)

# Display the image
def display_image(title, image):
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.axis()

display_image("Flipped Image", f_image)

#Step 6: Rotate the image

(h,w) = image.shape[:2]
center = (w//2,h//2)
M = cv2.getRotationMatrix2D(center,45,1.0)
rotated_image = cv2.warpAffine(image,M,(w,h))

display_image("Rotated Image",rotated_image)

#Step 7: Apply Gaussian Blur

blurred_image = cv2.GaussianBlur(image, (15,15), 0)
display_image("Blurred Image",blurred_image)

#Step8: Sharpen the image
kernel = np.array([[0,-1,0],[-1,5,-1],[0,-1,0]])
sharpened_image = cv2.filter2D(image,-1,kernel)
display_image("Sharepened image",sharpened_image)

#Step 9: Boost Color

boosted_image = cv2.convertScaleAbs(image,alpha=1.5,beta=0)
display_image("Boosted Image",boosted_image)

#Step 10: Sketch Effect
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
inverted_gray = 255 - gray
blurred = cv2.GaussianBlur(gray, (21,21), 0)
sketch_image = cv2.divide(gray,255-blurred, scale = 256)
display_image("Sketch Image",sketch_image)



# Step 11: Create a Collage
# Resize images to same size for collage
cropped_resized = cv2.resize(cropped_image, (200, 200))
flipped_resized = cv2.resize(flipped_image, (200, 200))
blurred_resized = cv2.resize(blurred_image, (200, 200))
boosted_resized = cv2.resize(boosted_image, (200, 200))

# Concatenate images to form a collage
collage_top = np.concatenate((cropped_resized, flipped_resized), axis=1)
collage_bottom = np.concatenate((blurred_resized, boosted_resized), axis=1)
collage = np.concatenate((collage_top, collage_bottom), axis=0)

display_image("Image Collage", collage)

# get the histogram of the pixcel values
hist = cv2.calcHist([image], [0], None, [256], [0, 256])

# plot the histogram
plt.plot(hist)
plt.title("Histogram")
plt.xlabel("Pixel Value")
plt.ylabel("Frequency")
plt.show()

# Step 14: Edge Detection using Canny
edges = cv2.Canny(grayscale_image, 100, 200)  # Use Canny edge detection
display_image("Edge Detected Image", edges)

# Step 15: Corner Detection using Harris Corner Detector
dst = cv2.cornerHarris(grayscale_image, 2, 3, 0.04)
dst = cv2.dilate(dst, None)  # Dilate to mark the corners better
corner_image = image.copy()
corner_image[dst > 0.01 * dst.max()] = [0, 0, 255]  # Mark corners in red
display_image("Corner Detected Image", corner_image)

# Step 16: Convolution Operation
# Define a simple kernel for convolution (e.g., edge detection kernel)
conv_kernel = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])
convolved_image = cv2.filter2D(image, -1, conv_kernel)
display_image("Convolved Image", convolved_image)

# read an image
image2 = cv2.imread('example.jpg')

print(image2.shape)

display_image("Original Image", image2)

# Step 17: Corner Detection using Convolution Kernel
# Define a kernel for corner detection (e.g., approximation of Harris response)
corner_kernel = np.array([[1, -1, 1], [-1, -4, -1], [1, -1, 1]])
corner_convolved_image = cv2.filter2D(image2, -1, corner_kernel)
display_image("Corner Detected using Convolution Kernel", corner_convolved_image)

conv_kernel = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])
convolved_image = cv2.filter2D(image2, -1, conv_kernel)
display_image("Convolved Image", convolved_image)

# Step 18: Masking of an Image
# Create a circular mask
mask = np.zeros(image.shape[:2], dtype=np.uint8)
center_coordinates = (image.shape[1] // 2, image.shape[0] // 2)  # Center of the image
radius = 100
cv2.circle(mask, center_coordinates, radius, 255, -1)  # Draw a filled circle (white area is the mask)

# Apply the mask to the image
masked_image = cv2.bitwise_and(image, image, mask=mask)
display_image("Masked Image", masked_image)

